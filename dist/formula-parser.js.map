{
  "version": 3,
  "sources": ["../src/errors.js", "../src/split.js", "../src/group.js", "../src/evaluate.js", "../src/index.js"],
  "sourcesContent": ["export class ParseError extends Error {\n    constructor(message, tokens) {\n        super(message)\n        this.tokens = tokens\n    }\n}\n\nexport class EvaluationError extends Error {\n    constructor(message, index) {\n        super(message)\n        this.index = index\n    }\n}", "import { ParseError } from \"./errors.js\"\n\nexport default function split(expression) {\n    const operators = [\n        '(',\n        ')',\n        ':',\n        ',',\n        '+',\n        '-',\n        '*',\n        '/',\n        '%',\n        '=',\n        '<',\n        '>',\n        '&',\n        '|'\n    ]\n    const quote = '\"'\n    const result = []\n\n    let start = 0\n    let in_quote = false\n    const add = i => {\n        let value = expression.slice(start, i)\n\n        if (in_quote) result.push({ value, type: 'text', start: start - 1 })\n        else {\n            value = value.trim()\n            if (value.length) {\n                if (!isNaN(value))\n                    result.push({\n                        value: parseFloat(value),\n                        type: 'number',\n                        start\n                    })\n                else if (value.toLowerCase() === 'true')\n                    result.push({ value: true, type: 'boolean', start })\n                else if (value.toLowerCase() === 'false')\n                    result.push({ value: false, type: 'boolean', start })\n                else result.push({ value, type: 'reference', start })\n            }\n        }\n\n        start = i + 1\n    }\n\n    for (let i = 0; i < expression.length; i++) {\n        const c = expression[i]\n        const last = () => expression[i - 1]\n        const next = () => expression[i + 1]\n        const test_quote = () => c === quote && last() !== '\\\\'\n\n        if (in_quote) {\n            if (test_quote()) {\n                add(i)\n                in_quote = false\n                continue\n            }\n        }\n\n        if (test_quote()) {\n            add(i)\n            in_quote = true\n            continue\n        }\n\n        if (operators.includes(c)) {\n            add(i)\n            const type = 'operator'\n            if (['<', '>', '!'].includes(c) && next() === '=') {\n                start++\n                i++\n                result.push({ value: c + '=', type, start: i - 1 })\n                continue\n            }\n            result.push({ value: c, type, start: i })\n        }\n    }\n    if (in_quote) throw new ParseError('Expression ends in unclosed quote.', result)\n    add()\n\n    return result\n}", "import { ParseError } from \"./errors.js\"\n\nexport default function group(tokens) {\n    const result = []\n    const stack = []\n    let current = result\n\n    for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i]\n\n        if (token.value === '(' && token.type === 'operator') {\n            stack.push(current)\n            current = []\n            continue\n        }\n        if (token.value === ')' && token.type === 'operator') {\n            const parent = stack.pop()\n            if (parent[parent.length - 1]?.type === 'reference') {\n                parent[parent.length - 1].type = 'function'\n                parent[parent.length - 1].arguments = current\n            } else parent.push(current)\n\n            current = parent\n            continue\n        } else current.push(token)\n    }\n    if (stack.length) throw new ParseError(`Expression ends in unclosed parenthesis.`, result)\n\n    return result\n}", "import { EvaluationError } from \"./errors.js\"\n\nexport default function evaluate(expression, context, functions) {\n    const get = token => {\n        if (!token) return\n        if (token.type === 'operator') return token\n        if (Array.isArray(token)) return evaluate(token, context)\n        if (token.type === 'reference')\n            return context[token.value] ?? functions[token.value]\n        if (token.type === 'function') {\n            if (!functions[token.value]?.call)\n                throw new EvaluationError(\n                    `Function \"${token.value}\" not implemented.`, token.start\n                )\n            return functions[token.value]?.call(\n                context,\n                evaluate(token.arguments)\n            )\n        }\n        return token.value\n    }\n\n    let current = get(expression[0])\n\n    if (current?.type === 'operator')\n        throw new EvaluationError('Expression cannot start with an operator.', 0)\n\n    for (let i = 1; i < expression.length; i += 2) {\n        const b = get(expression[i])\n        const c = get(expression[i + 1])\n\n        if (b?.type !== 'operator')\n            throw new EvaluationError(\n                `Expression cannot contain 2 consecutive values.`, b.start\n            )\n        if (c?.type === 'operator')\n            throw new Error(\n                `Expression cannot contain 2 consecutive operators.`, c.start\n            )\n\n        switch (b.value) {\n            case '+':\n                current += c\n                continue\n            case '-':\n                current -= c\n                continue\n            case '*':\n                current *= c\n                continue\n            case '/':\n                current /= c\n                continue\n            case '%':\n                current %= c\n                continue\n            case ':':\n                current = {\n                    [current]: c\n                }\n                continue\n            case ',':\n                if (typeof current === 'object') {\n                    if (Array.isArray(current)) current = [...current, c]\n                    else {\n                        i+=2\n                        if (i >= expression.length)\n                            throw new EvaluationError('Expression contains unclosed object.', c.start)\n\n                        const d = get(expression[i])\n                        const e = get(expression[i + 1])\n                        if (d.type !== 'operator' && d.value !== ':')\n                            throw new EvaluationError('Expression object must follow key:value format.', d.start)\n                        if (e.type === 'operator')\n                            throw new EvaluationError('Expression object must follow key:value format.', e.start)\n\n                        current = {\n                            ...current,\n                            [c]: e\n                        }\n                    }\n                }\n                \n                else current = [current, c]\n                continue\n            case '=':\n                current = current == c\n                continue\n            case '!=':\n                current = current != c\n                continue\n            case '<':\n                current = current < c\n                continue\n            case '<=':\n                current = current <= c\n                continue\n            case '>':\n                current = current > c\n                continue\n            case '>=':\n                current = current >= c\n                continue\n            case '&':\n                current = current && c\n                continue\n            case '|':\n                current = current || c\n                continue\n        }\n        throw new EvaluationError(`Operator \"${b.value}\" not implemented.`, b.start)\n    }\n\n    return current\n}", "import split from './split.js'\nimport group from './group.js'\nimport evaluate from './evaluate.js'\n\nexport { evaluate }\n\n/**\n * @param {string} expression \n */\nexport default function parse(text) {\n    try {\n        const tokens = split(text)\n        const expression = group(tokens)\n        return {\n            text,\n            tokens,\n            expression,\n            evaluate: (context = {}, functions = {}) => evaluate(expression, context, functions)\n        }\n    }\n    catch (e) {\n        return {\n            error: e.message,\n            text,\n            tokens: e?.tokens,\n            expression,\n            evaluate: () => {\n                throw new EvaluationError(e.message)\n            }\n        }\n    }\n}"],
  "mappings": "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",
  "names": ["EvaluationError", "expression", "expression", "EvaluationError", "expression"]
}
